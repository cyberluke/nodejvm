{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 This repository demonstrates how to use NodeJS/npm modules directly from Java and Kotlin. Why is it useful: Gain access to unique JavaScript modules, like the Dat peer to peer file sharing framework shown in the samples. Combine your existing NodeJS and Java servers together, eliminating the overheads of REST, serialisation, two separate virtual machines. Simplify your microservices architecture into being a polyglot architecture instead. Use it to start porting NodeJS apps to the JVM world and languages, incrementally, one chunk at a time, whilst always having a runnable app. Or do the reverse. How does it work? \u00b6 GraalVM is a modified version of OpenJDK that includes the cutting edge Graal and Truffle compiler infrastructure. It provides an advanced JavaScript engine that has competitive performance with V8, and also a modified version of NodeJS 10 that swaps out V8 for this enhanced JVM. In this way you can fuse together NodeJS and the JVM, allowing apps to smoothly access both worlds simultaneously with full JIT compilation. Known limitations \u00b6 NodeJS really wants to load module files from the filesystem and nowhere else, so your Java app will need a node_modules directory from where it's started. There are tricks to work around this and allow bundling of JS into JAR files as libraries, but nothing done at the moment. GraalVM uses NodeJS 10, not the latest versions. You change java on the command line to nodejvm and that's all it needs, but many tools and IDEs expect the java launcher to always be called java .","title":"Introduction"},{"location":"#introduction","text":"This repository demonstrates how to use NodeJS/npm modules directly from Java and Kotlin. Why is it useful: Gain access to unique JavaScript modules, like the Dat peer to peer file sharing framework shown in the samples. Combine your existing NodeJS and Java servers together, eliminating the overheads of REST, serialisation, two separate virtual machines. Simplify your microservices architecture into being a polyglot architecture instead. Use it to start porting NodeJS apps to the JVM world and languages, incrementally, one chunk at a time, whilst always having a runnable app. Or do the reverse.","title":"Introduction"},{"location":"#how-does-it-work","text":"GraalVM is a modified version of OpenJDK that includes the cutting edge Graal and Truffle compiler infrastructure. It provides an advanced JavaScript engine that has competitive performance with V8, and also a modified version of NodeJS 10 that swaps out V8 for this enhanced JVM. In this way you can fuse together NodeJS and the JVM, allowing apps to smoothly access both worlds simultaneously with full JIT compilation.","title":"How does it work?"},{"location":"#known-limitations","text":"NodeJS really wants to load module files from the filesystem and nowhere else, so your Java app will need a node_modules directory from where it's started. There are tricks to work around this and allow bundling of JS into JAR files as libraries, but nothing done at the moment. GraalVM uses NodeJS 10, not the latest versions. You change java on the command line to nodejvm and that's all it needs, but many tools and IDEs expect the java launcher to always be called java .","title":"Known limitations"},{"location":"concurrency/","text":"Concurrency and access to the JavaScript world \u00b6 Java and JavaScript execute on different threads by default, and thus will execute concurrently. Warning You can only access JavaScript objects from the NodeJS thread. This is important. NodeJS will use the JVM heap, so you can store references to JS objects wherever you like, however, due to the need to synchronize with the Node event loop, even something as simple as calling toString() on a JavaScript object will fail unless you are on the right thread. This is because JavaScript is not thread safe, does not provide any kind of shared memory concurrency and generally implements rules similar to Visual Basic 6. Learn more here . To run NodeJS code you must therefore enter the Node thread . In Java this is done by passing a lambda into NodeJS.runJS or NodeJS.runJSAsync . The calling Java thread will pause, wait for NodeJS to reach its main loop (if it's doing something) and then the lambda will be executed on the node thread. You can then call in and out of JavaScript to your hearts content: // Will block and wait for the JavaScript thread to become available. int result = NodeJS . runJS (() -> NodeJS . eval ( \"return 2 + 3 + 4\" ). asInt () ); In Kotlin, entering a nodejs { } block will synchronize with the NodeJS thread. It's safe to enter the NodeJS thread anywhere. You can nest entries inside each other, as if you enter Node whilst already on the event loop thread it will simply execute the lambda/code block immediately. Just remember not to block the NodeJS main thread itself: everything in JavaScript land is event driven. Things you might do that accidentally halt all JavaScript execution include: Reading or writing to a socket. Accessing a file (may be slow if it's over a network mount). Call Thread.sleep(). Do a long and intensive calculation.","title":"Concurrency and access to the JavaScript world"},{"location":"concurrency/#concurrency-and-access-to-the-javascript-world","text":"Java and JavaScript execute on different threads by default, and thus will execute concurrently. Warning You can only access JavaScript objects from the NodeJS thread. This is important. NodeJS will use the JVM heap, so you can store references to JS objects wherever you like, however, due to the need to synchronize with the Node event loop, even something as simple as calling toString() on a JavaScript object will fail unless you are on the right thread. This is because JavaScript is not thread safe, does not provide any kind of shared memory concurrency and generally implements rules similar to Visual Basic 6. Learn more here . To run NodeJS code you must therefore enter the Node thread . In Java this is done by passing a lambda into NodeJS.runJS or NodeJS.runJSAsync . The calling Java thread will pause, wait for NodeJS to reach its main loop (if it's doing something) and then the lambda will be executed on the node thread. You can then call in and out of JavaScript to your hearts content: // Will block and wait for the JavaScript thread to become available. int result = NodeJS . runJS (() -> NodeJS . eval ( \"return 2 + 3 + 4\" ). asInt () ); In Kotlin, entering a nodejs { } block will synchronize with the NodeJS thread. It's safe to enter the NodeJS thread anywhere. You can nest entries inside each other, as if you enter Node whilst already on the event loop thread it will simply execute the lambda/code block immediately. Just remember not to block the NodeJS main thread itself: everything in JavaScript land is event driven. Things you might do that accidentally halt all JavaScript execution include: Reading or writing to a socket. Accessing a file (may be slow if it's over a network mount). Call Thread.sleep(). Do a long and intensive calculation.","title":"Concurrency and access to the JavaScript world"},{"location":"language-injection/","text":"Language injection \u00b6 IntelliJ offers \"language injection\", which means a file can contain multiple languages at once. To benefit from this you unfortunately have to flip a switch in the IDE settings: Open your preferences and go to Editor > Language Injection > Advanced Under \"Performance\" select \"Enable data flow analysis\" Any string passed to eval will now be highlighted and edited as JavaScript, not a Java/Kotlin/Scala/etc string literal. Like this: Question If the feature doesn't seem to work, make sure you aren't passing the string through some other function first. Kotlin multi-line strings often get a .trimIndent() appended automatically, which is unfortunately sufficient to break the dataflow analysis and stop IntelliJ recognising that the language of the string hasn't changed. You can just take it out: JS isn't sensitive to leading whitespace.","title":"Language injection"},{"location":"language-injection/#language-injection","text":"IntelliJ offers \"language injection\", which means a file can contain multiple languages at once. To benefit from this you unfortunately have to flip a switch in the IDE settings: Open your preferences and go to Editor > Language Injection > Advanced Under \"Performance\" select \"Enable data flow analysis\" Any string passed to eval will now be highlighted and edited as JavaScript, not a Java/Kotlin/Scala/etc string literal. Like this: Question If the feature doesn't seem to work, make sure you aren't passing the string through some other function first. Kotlin multi-line strings often get a .trimIndent() appended automatically, which is unfortunately sufficient to break the dataflow analysis and stop IntelliJ recognising that the language of the string hasn't changed. You can just take it out: JS isn't sensitive to leading whitespace.","title":"Language injection"},{"location":"running-polyglot-programs/","text":"Running polyglot programs \u00b6 Download the latest release from the releases page . Now add the nodejvm directory to your path, or copy the contents to somewhere on your path. Start your Java programs as normal but run nodejvm instead of java , e.g. nodejvm -cp \"libs/*.jar\" my.main.Class arg1 arg2 Running the samples \u00b6 Check out the NodeJVM repository. Then try: gradle dat - sample : run It should join the DAT network and might print some peer infos, depending on your luck. Also try something a bit less Gradley: gradle build spinners - sample : shadowJar .. / build / nodejvm / nodejvm - jar build / libs / spinners - sample -*- all . jar From Gradle \u00b6 The easiest way is to adjust your JavaCompile tasks to run nodejvm instead of java : tasks . withType < JavaExec > { executable ( \"nodejvm\" ) } This requires nodejvm to be on your PATH and JAVA_HOME to be pointed at GraalVM. There's no support for automatically downloading NodeJVM or Graal itself at this time. If you use the application plugin to generate startup scripts, then at the moment you will have to edit the script by hand because it really wants nodejvm to be called java . Alternatively you could symlink nodejvm to be named java and put that on your PATH so it overrides the default Java install, but again, this would be up to your users to do. This is an area of focus for future improvement.","title":"Running polyglot programs"},{"location":"running-polyglot-programs/#running-polyglot-programs","text":"Download the latest release from the releases page . Now add the nodejvm directory to your path, or copy the contents to somewhere on your path. Start your Java programs as normal but run nodejvm instead of java , e.g. nodejvm -cp \"libs/*.jar\" my.main.Class arg1 arg2","title":"Running polyglot programs"},{"location":"running-polyglot-programs/#running-the-samples","text":"Check out the NodeJVM repository. Then try: gradle dat - sample : run It should join the DAT network and might print some peer infos, depending on your luck. Also try something a bit less Gradley: gradle build spinners - sample : shadowJar .. / build / nodejvm / nodejvm - jar build / libs / spinners - sample -*- all . jar","title":"Running the samples"},{"location":"running-polyglot-programs/#from-gradle","text":"The easiest way is to adjust your JavaCompile tasks to run nodejvm instead of java : tasks . withType < JavaExec > { executable ( \"nodejvm\" ) } This requires nodejvm to be on your PATH and JAVA_HOME to be pointed at GraalVM. There's no support for automatically downloading NodeJVM or Graal itself at this time. If you use the application plugin to generate startup scripts, then at the moment you will have to edit the script by hand because it really wants nodejvm to be called java . Alternatively you could symlink nodejvm to be named java and put that on your PATH so it overrides the default Java install, but again, this would be up to your users to do. This is an area of focus for future improvement.","title":"From Gradle"},{"location":"types/","text":"Type conversions \u00b6 The Graal API uses a variant type called Value . JavaScript objects returned through eval are mapped to Java/JVM world objects in a fairly sophisticated way, as described in the Graal SDK documentation . Briefly: Strings and numbers work as you'd expect. JavaScript numbers can be larger than a Java number type, if the number wouldn't fit then ClassCastException is thrown. Date and time values are mapped to java.time types. Exceptions can be mapped to PolyglotException . Things with members i.e. objects can be mapped to Map<String, Any> JavaScript lists can be converted to List<T> or a Java array. It's more efficient to use List<T> . JavaScript functions can be converted to lambdas/functional interfaces. JavaScript objects can be converted to interfaces, which get special behaviours (see below). You can also go the other way. Interfaces \u00b6 You can cast a Value to an interface. Special rules apply that map JavaBean property name conventions to JavaScript. If a method starts with \"get\" or \"is\" then calling it is treated as a property read. If a method starts with \"set\" then calling it is treated as a property write, with the names being mapped appropriately. Kotlin val and var map to JavaBean style methods under the hood, so they should map transparently. Automatic conversion from TypeScript \u00b6 There is a project called Dukat that is working on automatic conversion of TypeScript to Kotlin declarations. Because Kotlin code can also be accessed from Java, this would be also useful for Java developers. Dukat is still under heavy development and would need some small adjustments for NodeJVM, but it's an avenue for future work.","title":"Type conversions"},{"location":"types/#type-conversions","text":"The Graal API uses a variant type called Value . JavaScript objects returned through eval are mapped to Java/JVM world objects in a fairly sophisticated way, as described in the Graal SDK documentation . Briefly: Strings and numbers work as you'd expect. JavaScript numbers can be larger than a Java number type, if the number wouldn't fit then ClassCastException is thrown. Date and time values are mapped to java.time types. Exceptions can be mapped to PolyglotException . Things with members i.e. objects can be mapped to Map<String, Any> JavaScript lists can be converted to List<T> or a Java array. It's more efficient to use List<T> . JavaScript functions can be converted to lambdas/functional interfaces. JavaScript objects can be converted to interfaces, which get special behaviours (see below). You can also go the other way.","title":"Type conversions"},{"location":"types/#interfaces","text":"You can cast a Value to an interface. Special rules apply that map JavaBean property name conventions to JavaScript. If a method starts with \"get\" or \"is\" then calling it is treated as a property read. If a method starts with \"set\" then calling it is treated as a property write, with the names being mapped appropriately. Kotlin val and var map to JavaBean style methods under the hood, so they should map transparently.","title":"Interfaces"},{"location":"types/#automatic-conversion-from-typescript","text":"There is a project called Dukat that is working on automatic conversion of TypeScript to Kotlin declarations. Because Kotlin code can also be accessed from Java, this would be also useful for Java developers. Dukat is still under heavy development and would need some small adjustments for NodeJVM, but it's an avenue for future work.","title":"Automatic conversion from TypeScript"},{"location":"using-from-java/","text":"Using from Java \u00b6 The NodeJS class gives you access to the JavaScript runtime: import net.plan99.nodejs.NodeJS ; public class Demo { public static void main ( String [] args ) { int result = NodeJS . runJS (() -> NodeJS . eval ( \"return 2 + 3 + 4\" ). asInt () ); System . out . println ( result ); } } Evaluate JavaScript code with the eval static method. Before you can use it, you need to get yourself onto the NodeJS main thread by providing a lambda to NodeJS.runJS . See below for more info on this. What you get back from eval is a GraalVM Polyglot Value class ( javadoc ). Documentation for the Polyglot API is here . There is also a NodeJS.runJSAsync method which returns a CompletableFuture with the result of the lambda, instead of waiting, and an Executor that executes jobs on the NodeJS thread. The executor can be useful if you don't want to return anything from the JS code: NodeJS . executor . execute (() -> { NodeJS . eval ( \"require('some-module').doSomething()\" ); } But you can also use it in many other ways, as the Executor type is a general way to schedule work onto other threads in Java. Casting \u00b6 It can be useful to convert Value to a more convenient type. Many such type conversions are available. The Polyglot API has conveniences for many of them on the Value object itself, like Value.asBoolean() , Value.asString() , Value.asLong() etc. For objects, NodeJVM provides an extra bit of glue to make JavaBean style properties work. To benefit, you must unfortunately use a little boilerplate to ensure generics are preserved. Cast like this: MyInterface ora = NodeJS . castValue ( v , new TypeLiteral < MyInterface >() {}); If you passed a Java object into JavaScript and have now got it back again, use Value.asHostObject() to unwrap it. Bindings \u00b6 You will often want to put a Java object into the JavaScript environment. That's done using the Polyglot bindings API. The bindings are a string to object map which acts as a kind of transfer area. You insert objects into the bindings with a name, and then in JavaScript use Polyglot.import() to retrieve it: class Bindings { static void demo () { NodeJS . polyglotContext (). getPolyglotBindings (). putMember ( \"props\" , System . getProperties () ); NodeJS . executor . execute (() -> { NodeJS . eval ( \"const props = Polyglot.import('props');\" + \"console.log(props.get('java.version'));\" ); }); } } This program will expose the Java system properties to JavaScript and then print the Java runtime version.","title":"Using from Java"},{"location":"using-from-java/#using-from-java","text":"The NodeJS class gives you access to the JavaScript runtime: import net.plan99.nodejs.NodeJS ; public class Demo { public static void main ( String [] args ) { int result = NodeJS . runJS (() -> NodeJS . eval ( \"return 2 + 3 + 4\" ). asInt () ); System . out . println ( result ); } } Evaluate JavaScript code with the eval static method. Before you can use it, you need to get yourself onto the NodeJS main thread by providing a lambda to NodeJS.runJS . See below for more info on this. What you get back from eval is a GraalVM Polyglot Value class ( javadoc ). Documentation for the Polyglot API is here . There is also a NodeJS.runJSAsync method which returns a CompletableFuture with the result of the lambda, instead of waiting, and an Executor that executes jobs on the NodeJS thread. The executor can be useful if you don't want to return anything from the JS code: NodeJS . executor . execute (() -> { NodeJS . eval ( \"require('some-module').doSomething()\" ); } But you can also use it in many other ways, as the Executor type is a general way to schedule work onto other threads in Java.","title":"Using from Java"},{"location":"using-from-java/#casting","text":"It can be useful to convert Value to a more convenient type. Many such type conversions are available. The Polyglot API has conveniences for many of them on the Value object itself, like Value.asBoolean() , Value.asString() , Value.asLong() etc. For objects, NodeJVM provides an extra bit of glue to make JavaBean style properties work. To benefit, you must unfortunately use a little boilerplate to ensure generics are preserved. Cast like this: MyInterface ora = NodeJS . castValue ( v , new TypeLiteral < MyInterface >() {}); If you passed a Java object into JavaScript and have now got it back again, use Value.asHostObject() to unwrap it.","title":"Casting"},{"location":"using-from-java/#bindings","text":"You will often want to put a Java object into the JavaScript environment. That's done using the Polyglot bindings API. The bindings are a string to object map which acts as a kind of transfer area. You insert objects into the bindings with a name, and then in JavaScript use Polyglot.import() to retrieve it: class Bindings { static void demo () { NodeJS . polyglotContext (). getPolyglotBindings (). putMember ( \"props\" , System . getProperties () ); NodeJS . executor . execute (() -> { NodeJS . eval ( \"const props = Polyglot.import('props');\" + \"console.log(props.get('java.version'));\" ); }); } } This program will expose the Java system properties to JavaScript and then print the Java runtime version.","title":"Bindings"},{"location":"using-from-kotlin/","text":"Using from Kotlin \u00b6 \ud83d\udcda Read the Kotlin API Docs Kotlin provides many features that make it much more convenient and pleasant to work with NodeJS from the JVM. The API is available only inside a nodejs { } block. You may evaluate JavaScript when inside a nodejs block, like so: val i : Int = nodejs { eval ( \"2 + 2 + 4\" ) } Kotlin's type inference combined with GraalJS and the Polyglot infrastructure ensures that you can take the result of eval and stick it into a normal Kotlin variable most of the time. Polyglot casts will be performed automatically. If you don't want any return value, use run instead of eval : nodejs { run ( \"console.log('hi there, world')\" ) } The nodejs block synchronises with the NodeJS event loop, thus making access to the JavaScript engine safe. Remember Kotlin supports multi-line strings using \"\"\" . This is extremely convenient for embedding JavaScript into Kotlin files. If the string is passed in via a simple dataflow (with no intermediate methods) then IntelliJ will properly code highlight and do auto-complete for the embedded JavaScript via the language injection feature! Just watch out that a pointless .trimIndent() doesn't sneak in there, which will break injection. Values \u00b6 Value is GraalVM's generic variant type. It can be used to represent any JavaScript value. If you ask eval for a Value , you can use Kotlin's indexing operators to treat it as a dictionary: nodejs { val v : Value = eval ( \"process.memoryUsage()\" ) val heapTotal : Long = v [ \"heapTotal\" ] println ( \"JS heap total size is $heapTotal\" ) } When evaluated in NodeJS process.memoryUsage() will give you something like this: > process . memoryUsage () { rss : 22847488 , heapTotal : 9682944 , heapUsed : 6075560 , external : 12318 } So you can see how to use Kotlin's property access syntax in the same way you might in JS itself. But usually it's easier and better to cast a Value to some other more native type. Read about type conversions to learn how what's possible. To cast, you can either just ensure the return value of eval is assigned to the correct type, or you can use .cast<T> on a Value , like this: val str : String = value . cast () val str2 = value . cast < String >() Top level variable binding \u00b6 You'll often want to pass Java/Kotlin objects into the JS world. You can do this by binding a JavaScript variable to a Kotlin variable and then reading/writing to it as normal: nodejs { var list : List < String > by bind ( listOf ( \"a\" , \"b\" , \"c\" )) run ( \"console.log(list[0])\" ) run ( \"x = 5\" ) val x by bind < Int >() println ( \"$x == 5\" ) } bind is a function that optionally takes a default value and then connects the new variable to a top level JS variable with the same name. Recall that in JavaScript var creates a locally scoped variable, so to interop like this you must define JS variables at the top level without var . That's why we run x = 5 above and not var x = 5 . If we had used var then Kotlin wouldn't be able to see it. Interfaces \u00b6 It's highly convenient to cast Value to interfaces. NodeJVM adds some extra proxying on top of GraalVM Polyglot to make Kotlin (i.e. JavaBean) style properties map to JavaScript properties correctly. Here's how you can use the ora module that provides fancy spinners using the support for interface casting: interface Ora { fun start ( text : String ) fun info ( text : String ) fun warn ( text : String ) fun error ( text : String ) var text : String var prefixText : String ? var color : String } fun main () { val spinner : Ora = nodejs { eval ( \"require('ora')()\" ) } nodejs { spinner . start ( \"Loading unicorns ...\" ) } // We don't want to block the nodeJS thread by sleeping inside a nodejs{} block. // This sleep represents some sort of \"work\". Thread . sleep ( 2000 ) // Change color and message. nodejs { spinner . color = \"red\" spinner . text = \"Loading rainbows\" spinner . prefixText = \"Working\" } } Callbacks and lambdas \u00b6 You unfortunately cannot pass Kotlin lambdas straight into JavaScript due to KT-30107 . So you have to use the Java functional types instead, like this: nodejs { var callback1 by bind ( Consumer { m : Map < String , Any ?> -> val obj = m . asValue (). cast < MemoryUsage >() println ( \"rss is ${obj.rss()}\" ) }) run ( \"callback1(process.memoryUsage())\" ) } Due to a GraalJS bug, it always passes a JavaScript object into a lambda as Map , but you can easily convert it to an interface as seen above. Alternatively just make it a real public class .","title":"Using from Kotlin"},{"location":"using-from-kotlin/#using-from-kotlin","text":"\ud83d\udcda Read the Kotlin API Docs Kotlin provides many features that make it much more convenient and pleasant to work with NodeJS from the JVM. The API is available only inside a nodejs { } block. You may evaluate JavaScript when inside a nodejs block, like so: val i : Int = nodejs { eval ( \"2 + 2 + 4\" ) } Kotlin's type inference combined with GraalJS and the Polyglot infrastructure ensures that you can take the result of eval and stick it into a normal Kotlin variable most of the time. Polyglot casts will be performed automatically. If you don't want any return value, use run instead of eval : nodejs { run ( \"console.log('hi there, world')\" ) } The nodejs block synchronises with the NodeJS event loop, thus making access to the JavaScript engine safe. Remember Kotlin supports multi-line strings using \"\"\" . This is extremely convenient for embedding JavaScript into Kotlin files. If the string is passed in via a simple dataflow (with no intermediate methods) then IntelliJ will properly code highlight and do auto-complete for the embedded JavaScript via the language injection feature! Just watch out that a pointless .trimIndent() doesn't sneak in there, which will break injection.","title":"Using from Kotlin"},{"location":"using-from-kotlin/#values","text":"Value is GraalVM's generic variant type. It can be used to represent any JavaScript value. If you ask eval for a Value , you can use Kotlin's indexing operators to treat it as a dictionary: nodejs { val v : Value = eval ( \"process.memoryUsage()\" ) val heapTotal : Long = v [ \"heapTotal\" ] println ( \"JS heap total size is $heapTotal\" ) } When evaluated in NodeJS process.memoryUsage() will give you something like this: > process . memoryUsage () { rss : 22847488 , heapTotal : 9682944 , heapUsed : 6075560 , external : 12318 } So you can see how to use Kotlin's property access syntax in the same way you might in JS itself. But usually it's easier and better to cast a Value to some other more native type. Read about type conversions to learn how what's possible. To cast, you can either just ensure the return value of eval is assigned to the correct type, or you can use .cast<T> on a Value , like this: val str : String = value . cast () val str2 = value . cast < String >()","title":"Values"},{"location":"using-from-kotlin/#top-level-variable-binding","text":"You'll often want to pass Java/Kotlin objects into the JS world. You can do this by binding a JavaScript variable to a Kotlin variable and then reading/writing to it as normal: nodejs { var list : List < String > by bind ( listOf ( \"a\" , \"b\" , \"c\" )) run ( \"console.log(list[0])\" ) run ( \"x = 5\" ) val x by bind < Int >() println ( \"$x == 5\" ) } bind is a function that optionally takes a default value and then connects the new variable to a top level JS variable with the same name. Recall that in JavaScript var creates a locally scoped variable, so to interop like this you must define JS variables at the top level without var . That's why we run x = 5 above and not var x = 5 . If we had used var then Kotlin wouldn't be able to see it.","title":"Top level variable binding"},{"location":"using-from-kotlin/#interfaces","text":"It's highly convenient to cast Value to interfaces. NodeJVM adds some extra proxying on top of GraalVM Polyglot to make Kotlin (i.e. JavaBean) style properties map to JavaScript properties correctly. Here's how you can use the ora module that provides fancy spinners using the support for interface casting: interface Ora { fun start ( text : String ) fun info ( text : String ) fun warn ( text : String ) fun error ( text : String ) var text : String var prefixText : String ? var color : String } fun main () { val spinner : Ora = nodejs { eval ( \"require('ora')()\" ) } nodejs { spinner . start ( \"Loading unicorns ...\" ) } // We don't want to block the nodeJS thread by sleeping inside a nodejs{} block. // This sleep represents some sort of \"work\". Thread . sleep ( 2000 ) // Change color and message. nodejs { spinner . color = \"red\" spinner . text = \"Loading rainbows\" spinner . prefixText = \"Working\" } }","title":"Interfaces"},{"location":"using-from-kotlin/#callbacks-and-lambdas","text":"You unfortunately cannot pass Kotlin lambdas straight into JavaScript due to KT-30107 . So you have to use the Java functional types instead, like this: nodejs { var callback1 by bind ( Consumer { m : Map < String , Any ?> -> val obj = m . asValue (). cast < MemoryUsage >() println ( \"rss is ${obj.rss()}\" ) }) run ( \"callback1(process.memoryUsage())\" ) } Due to a GraalJS bug, it always passes a JavaScript object into a lambda as Map , but you can easily convert it to an interface as seen above. Alternatively just make it a real public class .","title":"Callbacks and lambdas"}]}